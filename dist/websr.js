!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.WebSR=t():e.WebSR=t()}(self,(()=>(()=>{"use strict";var e={58:function(e,t){var n=this&&this.__awaiter||function(e,t,n,i){return new(n||(n=Promise))((function(r,u){function s(e){try{a(i.next(e))}catch(e){u(e)}}function o(e){try{a(i.throw(e))}catch(e){u(e)}}function a(e){var t;e.done?r(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(s,o)}a((i=i.apply(e,t||[])).next())}))};Object.defineProperty(t,"__esModule",{value:!0}),t.default=class{constructor(e,t,n,i,r){this.device=e,this.canvas=n,this.resolution=t,this.textures={},this.buffers={},this.destroyed=!1,this.scale=i,this.debug=r;let u=this.canvas.getContext("webgpu");if(!(u instanceof GPUCanvasContext))throw new Error("Unable to load WebGPU context");this.context=u,this.context.configure({device:this.device,format:navigator.gpu.getPreferredCanvasFormat()}),this.textureUsage=GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT,this.bufferUsage=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST,this.debug&&(this.textureUsage=this.textureUsage|GPUTextureUsage.COPY_SRC,this.bufferUsage=this.bufferUsage|GPUBufferUsage.COPY_SRC),this.textures.output=this.context.getCurrentTexture()}readBuffer(e){return n(this,void 0,void 0,(function*(){if(!this.buffers[e])throw new Error(`No buffer with name ${e}`);const t=this.device.createCommandEncoder({label:`Read ${e} buffer encoder`}),n=this.buffers[e],i=this.device.createBuffer({label:"result buffer",size:n.size,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST});t.copyBufferToBuffer(n,0,i,0,i.size),this.device.queue.submit([t.finish()]),yield i.mapAsync(GPUMapMode.READ);let r=i.getMappedRange();return new Float32Array(r)}))}readTexture(e){return n(this,void 0,void 0,(function*(){if(!this.textures[e])throw new Error(`No texture with name ${e}`);const t=this.device.createCommandEncoder({label:`Read ${e} texture encoder`}),n=this.textures[e];let i=16;"rgba8unorm"===n.format&&(i=4),"r32float"===n.format&&(i=4);const r=this.device.createBuffer({label:"result buffer",size:n.width*n.height*i,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST});return t.copyTextureToBuffer({texture:this.textures[e]},{buffer:r,bytesPerRow:n.width*i},{width:n.width,height:n.height,depthOrArrayLayers:1}),this.device.queue.submit([t.finish()]),yield r.mapAsync(GPUMapMode.READ),"r32float"===n.format||"rgba32float"===n.format?new Float32Array(r.getMappedRange()):"rgba8unorm"===n.format?new Uint8ClampedArray(r.getMappedRange()):new Float32Array(0)}))}destroy(){this.device.destroy(),this.destroyed=!0}buffer(e,t){if(!this.buffers[e]){const n=(t=t||{}).width||this.resolution.width,i=t.height||this.resolution.height,r=t.channels||4,u=t.bitdepth||4;this.buffers[e]=this.device.createBuffer({label:e,size:n*i*r*u,usage:this.bufferUsage})}return this.buffers[e]}texture(e,t){return this.textures[e]||(t=t||{},this.textures[e]=this.device.createTexture({label:e,size:[t.width||this.resolution.width,t.height||this.resolution.height],format:t.format||"rgba32float",usage:this.textureUsage})),this.textures[e]}}},145:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0});const i=n(23);class r extends i.default{constructor(e,t,n,i){super(e,t,n),this.label="Anime4KConv112x4";const r=n.weights;this.createUniform("kernels","array<mat4x4f, 28>");let u="";for(let e=0;e<7;e++)u+=i?`\n                let pixel_val${e} = inputBuffer${e}[buff_ind];\n                result += kernels[${4*e}]*max(pixel_val${e}, vec4f(0.0));\n                result += kernels[${4*e+2}]*max(-1.0*pixel_val${e}, vec4f(0.0));\n            `:`\n                let pixel_val${e} = inputBuffer${e}[buff_ind];\n                result += kernels[${4*e+1}]*max(pixel_val${e}, vec4f(0.0));\n                result += kernels[${4*e+3}]*max(-1.0*pixel_val${e}, vec4f(0.0));`;this.shader=this.createStandardShader(`\n        \n          @compute @workgroup_size(${this.num_work_groups}, ${this.num_work_groups}) fn main( @builtin(global_invocation_id) id: vec3<u32>) {\n          \n                let x = id.x;\n                let y = id.y;\n                \n                let i = id.y*${this.resolution.width} + x;\n                var result  = vec4f(0.0, 0.0, 0.0, 0.0);\n                \n                let coord = vec2<i32>( i32(x), i32(y));\n               \n                let buff_ind = coord.y*${this.resolution.width} + coord.x;\n                ${u}\n                \n                outputBuffer[i] = result;\n          }\n        `),this.setUniform("kernels",new Float32Array(r)),this.defaultSetup()}defaultPipelineConfig(){return{label:`${this.label}-pipeline`,layout:"auto",compute:{module:this.shader,entryPoint:"main"}}}defaultBindGroup(){const e=[];return this.inputs.forEach((function(t,n){t instanceof GPUExternalTexture?e.push({binding:n,resource:t}):t instanceof GPUTexture?e.push({binding:n,resource:t.createView()}):t instanceof GPUBuffer&&e.push({binding:n,resource:{buffer:t}})})),this.uniforms.forEach(((t,n)=>{e.push({binding:n+this.inputs.length,resource:{buffer:this.buffers[t.name]}})})),this.output instanceof GPUBuffer&&e.push({binding:this.inputs.length+this.uniforms.length,resource:{buffer:this.output}}),0===e.length?null:this.device.createBindGroup({layout:this.pipeline.getBindGroupLayout(0),entries:e})}}t.default=r},82:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0});const i=n(23);class r extends i.default{constructor(e,t,n){super(e,t,n),this.label="Anime4KConv16x4";const i=n.weights,r=n.bias;this.createUniform("kernel_offsets","array<vec4f, 9>"),this.createUniform("kernels","array<mat4x4f, 36>"),this.createUniform("bias","vec4f"),this.shader=this.createStandardShader(`\n        \n          @compute @workgroup_size(${this.num_work_groups}, ${this.num_work_groups}) fn main( @builtin(global_invocation_id) id: vec3<u32>) {\n          \n                let x = id.x;\n                let y = id.y;\n                \n                let i = id.y*${this.resolution.width} + x;\n                var result  = vec4f(0.0, 0.0, 0.0, 0.0);\n                \n                let coord = vec2<i32>( i32(x), i32(y));\n                      \n                 for(var i = 0u; i < 9; i++){\n                   let pixel_loc = coord + vec2<i32>(kernel_offsets[i].xy);\n                   let buff_ind = pixel_loc.y*${this.resolution.width} + pixel_loc.x;\n                   \n                   let pix_val0 = inputBuffer0[buff_ind];\n                   let pix_val1 = inputBuffer1[buff_ind];\n                  \n                   result += kernels[i]*max(pix_val0, vec4f(0.0));\n                   result += kernels[i+9]*max(pix_val1, vec4f(0.0));\n                   result += kernels[i+18]*max(-1.0*pix_val0, vec4f(0.0));\n                   result += kernels[i+27]*max(-1.0*pix_val1, vec4f(0.0));\n                 } \n                 \n\n                    \n                result += bias;\n                \n                outputBuffer[i] = result;\n          }\n        `),this.setUniform("kernel_offsets",new Float32Array([-1,-1,0,0,-1,0,0,0,-1,1,0,0,0,-1,0,0,0,0,0,0,0,1,0,0,1,-1,0,0,1,0,0,0,1,1,0,0])),this.setUniform("kernels",new Float32Array(i)),this.setUniform("bias",new Float32Array(r)),this.defaultSetup()}}t.default=r},844:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0});const i=n(23);class r extends i.default{constructor(e,t,n){super(e,t,n),this.label="Anime4KConv3x4";const i=n.weights,r=n.bias;this.createUniform("kernel_offsets","array<vec4f, 9>"),this.createUniform("kernels","array<mat4x4f, 9>"),this.createUniform("bias","vec4f"),this.setUniform("kernel_offsets",new Float32Array([-1,-1,0,0,-1,0,0,0,-1,1,0,0,0,-1,0,0,0,0,0,0,0,1,0,0,1,-1,0,0,1,0,0,0,1,1,0,0])),this.setUniform("kernels",new Float32Array(i)),this.setUniform("bias",new Float32Array(r))}lazyLoadSetup(){const e=this.inputs[0]instanceof GPUExternalTexture?"textureLoad(inputTexture0, coord + offset)":"textureLoad(inputTexture0, coord + offset, 0)";this.shader=this.createStandardShader(`\n        \n          @compute @workgroup_size(${this.num_work_groups}, ${this.num_work_groups}) fn main( @builtin(global_invocation_id) id: vec3<u32>) {\n          \n                let x = id.x;\n                let y = id.y;\n                \n                let i = id.y*${this.resolution.width} + x;\n                var result  = vec4f(0.0, 0.0, 0.0, 0.0);\n                \n                let coord = vec2<i32>( i32(x), i32(y));\n                      \n                 for(var i = 0u; i < 9; i++){\n                   let offset = vec2<i32>(kernel_offsets[i].xy);\n                   result += kernels[i]*${e};\n                 } \n                    \n                result += bias;\n                \n                outputBuffer[i] = result;\n          }\n        `),this.pipeline=this.device.createComputePipeline(this.defaultPipelineConfig()),this.bindGroup=this.defaultBindGroup()}}t.default=r},14:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0});const i=n(23);class r extends i.default{constructor(e,t,n){super(e,t,n),this.label="Anime4KConv56x4";const i=n.weights,r=n.bias;this.createUniform("kernels","array<mat4x4f, 14>"),this.createUniform("bias","vec4f");let u="";for(let e=0;e<7;e++)u+=`\n            let pixel_val${e} = inputBuffer${e}[buff_ind];\n            result += kernels[${2*e}]*max(pixel_val${e}, vec4f(0.0));\n            result += kernels[${2*e+1}]*max(-1.0*pixel_val${e}, vec4f(0.0));\n            `;this.shader=this.createStandardShader(`\n        \n          @compute @workgroup_size(${this.num_work_groups}, ${this.num_work_groups}) fn main( @builtin(global_invocation_id) id: vec3<u32>) {\n          \n                let x = id.x;\n                let y = id.y;\n                \n                let i = id.y*${this.resolution.width} + x;\n                var result  = vec4f(0.0, 0.0, 0.0, 0.0);\n                \n                let coord = vec2<i32>( i32(x), i32(y));\n               \n                let buff_ind = coord.y*${this.resolution.width} + coord.x;\n                ${u}\n                      \n                result += bias;\n                \n                outputBuffer[buff_ind] = result;\n          }\n        `),this.setUniform("kernels",new Float32Array(i)),this.setUniform("bias",new Float32Array(r)),this.defaultSetup()}defaultPipelineConfig(){return{label:`${this.label}-pipeline`,layout:"auto",compute:{module:this.shader,entryPoint:"main"}}}defaultBindGroup(){const e=[];return this.inputs.forEach((function(t,n){t instanceof GPUExternalTexture?e.push({binding:n,resource:t}):t instanceof GPUTexture?e.push({binding:n,resource:t.createView()}):t instanceof GPUBuffer&&e.push({binding:n,resource:{buffer:t}})})),this.uniforms.forEach(((t,n)=>{e.push({binding:n+this.inputs.length,resource:{buffer:this.buffers[t.name]}})})),this.output instanceof GPUBuffer&&e.push({binding:this.inputs.length+this.uniforms.length,resource:{buffer:this.output}}),0===e.length?null:this.device.createBindGroup({layout:this.pipeline.getBindGroupLayout(0),entries:e})}}t.default=r},301:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0});const i=n(23);class r extends i.default{constructor(e,t,n){super(e,t,n),this.label="Anime4KConv8x4";const i=n.weights,r=n.bias;this.createUniform("kernel_offsets","array<vec4f, 9>"),this.createUniform("kernels","array<mat4x4f, 18>"),this.createUniform("bias","vec4f"),this.shader=this.createStandardShader(`\n        \n          @compute @workgroup_size(${this.num_work_groups}, ${this.num_work_groups}) fn main( @builtin(global_invocation_id) id: vec3<u32>) {\n          \n                let x = id.x;\n                let y = id.y;\n                \n                let i = id.y*${this.resolution.width} + x;\n                var result  = vec4f(0.0, 0.0, 0.0, 0.0);\n                \n                let coord = vec2<i32>( i32(x), i32(y));\n                      \n                 for(var i = 0u; i < 9; i++){\n                   let pixel_loc = coord + vec2<i32>(kernel_offsets[i].xy);\n                   let buff_ind = pixel_loc.y*${this.resolution.width} + pixel_loc.x;\n                   \n                   let pix_val = inputBuffer0[buff_ind];\n                  \n                   result += kernels[i]*max(pix_val, vec4f(0.0));\n                   result += kernels[i+9]*max(-1.0*pix_val, vec4f(0.0));\n                 } \n                    \n                result += bias;\n                \n                outputBuffer[i] = result;\n          }\n        `),this.setUniform("kernel_offsets",new Float32Array([-1,-1,0,0,-1,0,0,0,-1,1,0,0,0,-1,0,0,0,0,0,0,0,1,0,0,1,-1,0,0,1,0,0,0,1,1,0,0])),this.setUniform("kernels",new Float32Array(i)),this.setUniform("bias",new Float32Array(r)),this.defaultSetup()}}t.default=r},991:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0});const i=n(23);class r extends i.default{constructor(e,t,n){super(e,t,n),this.label="Anime4KConcat2",this.createUniform("bias","vec4f");const i=n.bias;this.shader=this.createStandardShader(`\n        \n          @compute @workgroup_size(${this.num_work_groups}, ${this.num_work_groups}) fn main( @builtin(global_invocation_id) id: vec3<u32>) {\n          \n                let x = id.x;\n                let y = id.y;\n                \n                let i = id.y*${this.resolution.width} + x;\n                var result  = vec4f(0.0, 0.0, 0.0, 0.0);\n                \n                let coord = vec2<i32>( i32(x), i32(y));\n               \n                let buff_ind = coord.y*${this.resolution.width} + coord.x;\n               \n                outputBuffer[buff_ind] = inputBuffer0[buff_ind] + inputBuffer1[buff_ind] + bias;\n          }\n        `),this.setUniform("bias",new Float32Array(i)),this.defaultSetup()}}t.default=r},24:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0});const i=n(200);class r extends i.default{constructor(e,t){super(e,t),this.label="DisplayLayer",this.vertexScale={width:1,height:1},this.sampler=this.device.createSampler({addressModeU:"repeat",addressModeV:"repeat",magFilter:"linear",minFilter:"linear",mipmapFilter:"linear"})}lazyLoadSetup(){const e=this.inputs[1]instanceof GPUExternalTexture,t=e?"textureSampleBaseClampToEdge(inputTexture, ourSampler, input.tex_coord)":"textureSample(inputTexture, ourSampler, input.tex_coord)";this.shader=this.device.createShaderModule({label:`${this.label}-shader`,code:`\n                \n                   ${this.defaultVertexShader()}\n                   @group(0) @binding(0) var<storage, read_write> inputBuffer0: array<vec4f>;\n                   @group(0) @binding(1) var inputTexture: ${e?"texture_external":"texture_2d<f32>"};\n                   @group(0) @binding(2) var ourSampler: sampler;\n                  \n                   @fragment fn fragmentMain(input: VertexShaderOutput) -> @location(0) vec4f {\n                      \n                        let x = ${this.resolution.width}.0*(input.tex_coord.x);\n                        let y = ${this.resolution.height}.0*(input.tex_coord.y);\n                        \n                        let y2 = u32(floor(y));\n                        let x2 = u32(floor(x));\n                        \n                        let i = y2*${Math.floor(this.resolution.width)} +  x2;\n                       \n                        let x_floor  = u32(fract(x)*2.0);\n                        let y_floor  = u32(fract(y)*2.0);\n                        \n                        //I don t know, I think this is right? I found this by trial and error\n                        let c_index: u32 = x_floor + y_floor*2;  \n        \n                        let value = inputBuffer0[i][c_index];\n                        \n                        let bicubic = ${t};\n                        \n                        return bicubic + vec4f(value);\n                    \n                      }            \n            `}),this.pipeline=this.device.createRenderPipeline(this.defaultPipelineConfig()),this.bindGroup=this.defaultBindGroup(),this.renderPassDescriptor=this.defaultRenderPassDescriptor()}defaultBindGroup(){const e=[];return this.inputs.forEach((function(t,n){t instanceof GPUExternalTexture?e.push({binding:n,resource:t}):t instanceof GPUTexture?e.push({binding:n,resource:t.createView()}):t instanceof GPUBuffer&&e.push({binding:n,resource:{buffer:t}})})),e.push({binding:this.inputs.length,resource:this.sampler}),this.device.createBindGroup({layout:this.pipeline.getBindGroupLayout(0),entries:e})}}t.default=r},530:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0});const i=n(200);class r extends i.default{constructor(e,t){super(e,t),this.label="DisplayLayer",this.vertexScale={width:1,height:1},this.sampler=this.device.createSampler({addressModeU:"repeat",addressModeV:"repeat",magFilter:"linear",minFilter:"linear",mipmapFilter:"linear"})}lazyLoadSetup(){const e=this.inputs[1]instanceof GPUExternalTexture,t=e?"textureSampleBaseClampToEdge(inputTexture, ourSampler, input.tex_coord)":"textureSample(inputTexture, ourSampler, input.tex_coord)";this.shader=this.device.createShaderModule({label:`${this.label}-shader`,code:`\n                \n                   ${this.defaultVertexShader()}\n                   @group(0) @binding(0) var<storage, read_write> inputBuffer0: array<vec4f>;\n                   @group(0) @binding(1) var inputTexture: ${e?"texture_external":"texture_2d<f32>"};\n                   @group(0) @binding(2) var ourSampler: sampler;\n                  \n                   @fragment fn fragmentMain(input: VertexShaderOutput) -> @location(0) vec4f {\n                      \n                        let x = ${this.resolution.width}.0*(input.tex_coord.x);\n                        let y = ${this.resolution.height}.0*(input.tex_coord.y);\n                        \n                        let y2 = u32(floor(y));\n                        let x2 = u32(floor(x));\n                        \n                        let i = y2*${Math.floor(this.resolution.width)} +  x2;\n      \n                        let bicubic = ${t};\n                        \n                        return bicubic + inputBuffer0[i];\n                    \n                      }            \n            `}),this.pipeline=this.device.createRenderPipeline(this.defaultPipelineConfig()),this.bindGroup=this.defaultBindGroup(),this.renderPassDescriptor=this.defaultRenderPassDescriptor()}defaultBindGroup(){const e=[];return this.inputs.forEach((function(t,n){t instanceof GPUExternalTexture?e.push({binding:n,resource:t}):t instanceof GPUTexture?e.push({binding:n,resource:t.createView()}):t instanceof GPUBuffer&&e.push({binding:n,resource:{buffer:t}})})),e.push({binding:this.inputs.length,resource:this.sampler}),this.device.createBindGroup({layout:this.pipeline.getBindGroupLayout(0),entries:e})}}t.default=r},49:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0});const i=n(200);class r extends i.default{constructor(e,t){super(e,t),this.label="DisplayLayer3C",this.vertexScale={width:1,height:1},this.sampler=this.device.createSampler({addressModeU:"repeat",addressModeV:"repeat",magFilter:"linear",minFilter:"linear",mipmapFilter:"linear"})}lazyLoadSetup(){const e=this.inputs[3]instanceof GPUExternalTexture,t=e?"textureSampleBaseClampToEdge(inputTexture, ourSampler, input.tex_coord)":"textureSample(inputTexture, ourSampler, input.tex_coord)";this.shader=this.device.createShaderModule({label:`${this.label}-shader`,code:`\n                \n                   ${this.defaultVertexShader()}\n                   @group(0) @binding(0) var<storage, read_write> inputBuffer0: array<vec4f>;\n                   @group(0) @binding(1) var<storage, read_write> inputBuffer1: array<vec4f>;\n                   @group(0) @binding(2) var<storage, read_write> inputBuffer2: array<vec4f>;\n                   @group(0) @binding(3) var inputTexture: ${e?"texture_external":"texture_2d<f32>"};\n                   @group(0) @binding(4) var ourSampler: sampler;\n                  \n                   @fragment fn fragmentMain(input: VertexShaderOutput) -> @location(0) vec4f {\n                      \n                        let x = ${this.resolution.width}.0*(input.tex_coord.x);\n                        let y = ${this.resolution.height}.0*(input.tex_coord.y);\n                        \n                        let y2 = u32(floor(y));\n                        let x2 = u32(floor(x));\n                        \n                        let i = y2*${Math.floor(this.resolution.width)} +  x2;\n                       \n                        let x_floor  = u32(fract(x)*2.0);\n                        let y_floor  = u32(fract(y)*2.0);\n                        \n                        //I don t know, I think this is right? I found this by trial and error\n                        let c_index: u32 = x_floor + y_floor*2;  \n        \n                        let value = inputBuffer0[i][c_index];\n                        let value1 = inputBuffer1[i][c_index];\n                        let value2 = inputBuffer2[i][c_index];\n                        \n                        let bicubic = ${t};\n                        \n                        return bicubic + vec4f(value, value1, value2, value2);\n                    \n                      }            \n            `}),this.pipeline=this.device.createRenderPipeline(this.defaultPipelineConfig()),this.bindGroup=this.defaultBindGroup(),this.renderPassDescriptor=this.defaultRenderPassDescriptor()}defaultPipelineConfig(){return{label:`${this.label}-pipeline`,layout:"auto",vertex:{module:this.shader,entryPoint:"vertexMain"},fragment:{module:this.shader,entryPoint:"fragmentMain",targets:[{format:this.output.format}]}}}defaultBindGroup(){const e=[];return this.inputs.forEach((function(t,n){t instanceof GPUExternalTexture?e.push({binding:n,resource:t}):t instanceof GPUTexture?e.push({binding:n,resource:t.createView()}):t instanceof GPUBuffer&&e.push({binding:n,resource:{buffer:t}})})),e.push({binding:this.inputs.length,resource:this.sampler}),this.device.createBindGroup({layout:this.pipeline.getBindGroupLayout(0),entries:e})}}t.default=r},23:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0});const i=n(297);class r extends i.default{constructor(e,t,n){super(e,t,n),this.num_work_groups=8}createStandardShader(e){return this.device.createShaderModule({label:`${this.label}-shader`,code:`\n              \n              ${this.computeShaderInputs()}\n              \n              ${e}\n        `})}computeShaderInputs(){const e=[];for(let t=0;t<this.inputs.length;t++)if(this.inputs[t]instanceof GPUTexture)e.push(`@group(0) @binding(${t}) var inputTexture${t}: texture_2d<f32>;`);else if(this.inputs[t]instanceof GPUExternalTexture)e.push(`@group(0) @binding(${t}) var inputTexture${t}: texture_external;`);else{if(!(this.inputs[t]instanceof GPUBuffer))throw console.log(this.inputs[t]),new Error("Input is undefined or non of the correct input type");e.push(`@group(0) @binding(${t}) var<storage, read_write> inputBuffer${t}: array<vec4f>;`)}return this.uniforms.forEach(((t,n)=>{e.push(`@group(0) @binding(${n+this.inputs.length}) var <uniform> ${t.name}: ${t.type};`)})),e.push(`@group(0) @binding(${this.inputs.length+this.uniforms.length}) var <storage, read_write> outputBuffer: array<vec4f>;`),e.join("\n")}defaultPipelineConfig(){return{label:`${this.label}-pipeline`,layout:"auto",compute:{module:this.shader,entryPoint:"main"}}}defaultSetup(){this.pipeline=this.device.createComputePipeline(this.defaultPipelineConfig()),this.bindGroup=this.defaultBindGroup()}lazyLoadSetup(){}run(){const e=this.device.createCommandEncoder({label:this.label});this.pipeline||this.lazyLoadSetup();const t=e.beginComputePass({label:this.label});t.setPipeline(this.pipeline),this.hasExternalTexture()&&(this.bindGroup=this.defaultBindGroup()),this.bindGroup&&t.setBindGroup(0,this.bindGroup),t.dispatchWorkgroups(Math.floor(this.resolution.width/this.num_work_groups),Math.floor(this.resolution.height/this.num_work_groups)),t.end(),this.device.queue.submit([e.finish()])}}t.default=r},297:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=class{constructor(e,t,n){this.context=globalThis.context,this.device=this.context.device,this.resolution=this.context.resolution,this.inputs=e,this.output=t,this.uniforms=[],this.buffers={},this.weights=n}createUniform(e,t){this.uniforms.push({name:e,type:t})}setUniform(e,t){const n=this.device.createBuffer({label:`layer-${this.label}-buffer-${e}`,size:t.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});this.device.queue.writeBuffer(n,0,t),this.buffers[e]=n}defaultBindGroup(){const e=[];return this.inputs.forEach((function(t,n){t instanceof GPUExternalTexture?e.push({binding:n,resource:t}):t instanceof GPUTexture?e.push({binding:n,resource:t.createView()}):t instanceof GPUBuffer&&e.push({binding:n,resource:{buffer:t}})})),this.uniforms.forEach(((t,n)=>{e.push({binding:n+this.inputs.length,resource:{buffer:this.buffers[t.name]}})})),this.output instanceof GPUBuffer&&e.push({binding:this.inputs.length+this.uniforms.length,resource:{buffer:this.output}}),0===e.length?null:this.device.createBindGroup({layout:this.pipeline.getBindGroupLayout(0),entries:e})}hasExternalTexture(){for(const e of this.inputs)if(e instanceof GPUExternalTexture)return!0;return!1}lazyLoadSetup(){}run(){}}},200:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0});const i=n(297);class r extends i.default{constructor(e,t,n){super(e,t,n),this.vertexScale=this.context.resolution}defaultVertexShader(){return`\n        \n             struct VertexShaderOutput {\n                @builtin(position) position: vec4f,\n                @location(0) tex_coord: vec2f,\n              };\n\n            @vertex\n            fn vertexMain( @builtin(vertex_index) vertexIndex : u32) ->  VertexShaderOutput{\n                let pos = array(\n                // 1st triangle\n                vec2f( -1.0,  -1.0),  // center\n                vec2f( 1.0,  -1.0),  // right, center\n                vec2f( -1.0,  1.0),  // center, top\n             \n                // 2st triangle\n                vec2f( -1.0,  1.0),  // center, top\n                vec2f( 1.0,  -1.0),  // right, center\n                vec2f( 1.0,  1.0),  // right, top\n              );\n             \n              var vsOutput: VertexShaderOutput;\n              let xy = pos[vertexIndex];\n              vsOutput.position = vec4f(xy, 0.0, 1.0);\n              vsOutput.tex_coord = xy*0.5 + 0.5;\n              vsOutput.tex_coord.y = - 1.0* vsOutput.tex_coord.y  + 1.0;\n               vsOutput.tex_coord.x =  vsOutput.tex_coord.x*${this.vertexScale.width};\n               vsOutput.tex_coord.y =  vsOutput.tex_coord.y*${this.vertexScale.height};\n              return vsOutput;\n            }\n        `}defaultPipelineConfig(){return{label:`${this.label}-pipeline`,layout:"auto",vertex:{module:this.shader,entryPoint:"vertexMain"},fragment:{module:this.shader,entryPoint:"fragmentMain",targets:[{format:this.output.format}]}}}defaultSetup(){this.pipeline=this.device.createRenderPipeline(this.defaultPipelineConfig()),this.bindGroup=this.defaultBindGroup(),this.renderPassDescriptor=this.defaultRenderPassDescriptor()}defaultRenderPassDescriptor(){return{label:`${this.label}-render-pass`,colorAttachments:[{view:this.output.createView(),clearValue:[0,0,0,1],loadOp:"clear",storeOp:"store"}]}}createStandardShader(e){return this.device.createShaderModule({label:`${this.label}-shader`,code:`\n          \n              ${this.defaultVertexShader()}\n              \n              ${this.fragmentShaderInputs()}\n              \n              ${e}\n        `})}fragmentShaderInputs(){const e=[];for(let t=0;t<this.inputs.length;t++){let n=this.inputs[t]instanceof GPUTexture?"texture_2d<f32>":"texture_external";e.push(`@group(0) @binding(0) var inputTexture${t}: ${n};`)}return this.uniforms.forEach(((t,n)=>{e.push(`@group(0) @binding(${n+this.inputs.length}) var <uniform> ${t.name}: ${t.type};`)})),e.join("\n")}run(){const e=this.device.createCommandEncoder({label:this.label});this.pipeline||this.lazyLoadSetup();const t=e.beginRenderPass(this.renderPassDescriptor);t.setPipeline(this.pipeline),this.hasExternalTexture()&&(this.bindGroup=this.defaultBindGroup()),this.bindGroup&&t.setBindGroup(0,this.bindGroup),t.draw(6),t.end(),this.device.queue.submit([e.finish()])}setOutput(e){this.output=e,this.renderPassDescriptor=this.defaultRenderPassDescriptor()}}t.default=r},863:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0});const i=n(200);class r extends i.default{constructor(e,t){super(e,t),this.label="Gaussian",this.createUniform("gaussian","array<vec3f, 3>"),this.createUniform("kernel_offsets","array<vec4f, 9>"),this.shader=this.createStandardShader("\n        \n                  @fragment fn fragmentMain(input: VertexShaderOutput) -> @location(0) vec4f {\n                  \n                     var val  = 0.0;\n                      \n                     for(var i = 0u; i < 3; i++){\n                     \n                        let a = vec3f(\n                            textureLoad(inputTexture0, vec2<i32>(input.tex_coord + kernel_offsets[i*3].xy), 0).x,\n                            textureLoad(inputTexture0, vec2<i32>(input.tex_coord + kernel_offsets[i*3].xy), 0).x,\n                            textureLoad(inputTexture0, vec2<i32>(input.tex_coord + kernel_offsets[i*3].xy), 0).x\n                        );\n                        \n                        val += dot(a, gaussian[i]);\n                      \n                    } \n                  \n                    \n                    return vec4f(val, val, val, 1.0);\n                  }                 \n        "),this.setUniform("gaussian",new Float32Array([.0675,.125,.0675,0,.125,.25,.125,0,.0675,.125,.0675,0])),this.setUniform("kernel_offsets",new Float32Array([-1,-1,0,0,0,-1,0,0,1,-1,0,0,-1,0,0,0,0,0,0,0,1,0,0,0,-1,1,0,0,0,1,0,0,1,1,0,0])),this.defaultSetup()}}t.default=r},831:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0});const i=n(200);class r extends i.default{constructor(e,t){super(e,t),this.createUniform("rgb2yuv","mat3x3f"),this.shader=this.createStandardShader("\n        \n               @fragment fn fragmentMain(input: VertexShaderOutput) -> @location(0) vec4f {\n              \n                    let color = textureLoad(inputTexture0, vec2<i32>(input.tex_coord), 0);       \n                    let yuv = rgb2yuv*color.xyz;\n          \n                return vec4f(yuv, 1.0);\n              }     \n        "),this.setUniform("rgb2yuv",new Float32Array([.299,-.1473,.615,1,.587,-.2886,-.51499,1,.114,.436,-.1001,1])),this.defaultSetup()}}t.default=r},540:function(e,t,n){var i=this&&this.__awaiter||function(e,t,n,i){return new(n||(n=Promise))((function(r,u){function s(e){try{a(i.next(e))}catch(e){u(e)}}function o(e){try{a(i.throw(e))}catch(e){u(e)}}function a(e){var t;e.done?r(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(s,o)}a((i=i.apply(e,t||[])).next())}))};Object.defineProperty(t,"__esModule",{value:!0});const r=n(58),u=n(518),s=n(386);t.default=class{constructor(e){if(!s.NetworkList[e.network_name])throw Error(`Network ${e.network_name} is not defined or implemented`);this.source=e.source;const t=this.source;this.resolution=e.resolution?e.resolution:{width:t instanceof HTMLVideoElement?t.videoWidth:t instanceof HTMLImageElement?t.naturalWidth:t.width,height:t instanceof HTMLVideoElement?t.videoHeight:t instanceof HTMLImageElement?t.naturalHeight:t.height};const n=s.NetworkScales[e.network_name];e.canvas?this.canvas=e.canvas:(this.canvas=new HTMLCanvasElement,this.canvas.width=this.resolution.width*n,this.canvas.height=this.resolution.height*n),this.scale=n,this.context=new r.default(e.gpu,this.resolution,this.canvas,this.scale,this.debug),globalThis.context=this.context,this.network=new s.NetworkList[e.network_name](e.weights),this.renderer=new u.default(this.network,this.source)}switchNetwork(e,t){if(!s.NetworkList[e])throw Error(`Network ${e} is not defined or implemented`);this.network=new s.NetworkList[e](t),this.renderer.switchNetwork(this.network)}static initWebGPU(){return i(this,void 0,void 0,(function*(){if(!navigator.gpu)return!1;const e=yield navigator.gpu.requestAdapter();if(!e)return!1;return(yield e.requestDevice())||!1}))}start(){return i(this,void 0,void 0,(function*(){yield this.renderer.start()}))}stop(){return i(this,void 0,void 0,(function*(){yield this.renderer.stop()}))}render(e){return i(this,void 0,void 0,(function*(){yield this.renderer.render(e)}))}destroy(){return i(this,void 0,void 0,(function*(){yield this.renderer.stop(),this.context.destroy()}))}}},892:function(e,t,n){var i=this&&this.__awaiter||function(e,t,n,i){return new(n||(n=Promise))((function(r,u){function s(e){try{a(i.next(e))}catch(e){u(e)}}function o(e){try{a(i.throw(e))}catch(e){u(e)}}function a(e){var t;e.done?r(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(s,o)}a((i=i.apply(e,t||[])).next())}))};Object.defineProperty(t,"__esModule",{value:!0});const r=n(181),u=n(844),s=n(49),o=n(82),a=n(145),f=n(991);class c extends r.default{constructor(e){super(e)}model(){const e=[],t=this.weights.layers,n=this.context;e.push(new u.default([n.input],n.buffer("conv2d_tf"),t.conv2d_tf)),e.push(new u.default([n.input],n.buffer("conv2d_tf1"),t.conv2d_tf1));for(let i=1;i<7;i++){let r=1==i?"conv2d_tf":`conv2d_${i-1}_tf`;e.push(new o.default([n.buffer(r),n.buffer(r+"1")],n.buffer(`conv2d_${i}_tf`),t[`conv2d_${i}_tf`])),e.push(new o.default([n.buffer(r),n.buffer(r+"1")],n.buffer(`conv2d_${i}_tf1`),t[`conv2d_${i}_tf1`]))}for(let i=0;i<3;i++){const r=[],u=[];for(let e=0;e<7;e++){let t=0==e?"conv2d_tf":`conv2d_${e}_tf`;r.push(n.buffer(t)),u.push(n.buffer(t+"1"))}const s=0==i?"conv2d_last_tf":`conv2d_last_tf${i}`;e.push(new a.default(r,n.buffer(`conv2d_last_${i}_pt1`),t[s],!0)),e.push(new a.default(u,n.buffer(`conv2d_last_${i}_pt2`),t[s],!1)),e.push(new f.default([n.buffer(`conv2d_last_${i}_pt1`),n.buffer(`conv2d_last_${i}_pt2`)],n.buffer(s),t[s]))}const i=new s.default([n.buffer("conv2d_last_tf"),n.buffer("conv2d_last_tf1"),n.buffer("conv2d_last_tf2"),n.input],n.texture("output"));return e.push(i),e}feedForward(e){return i(this,void 0,void 0,(function*(){if(e instanceof HTMLVideoElement)this.context.input=this.context.device.importExternalTexture({source:e});else{const t=e instanceof ImageBitmap?e:yield createImageBitmap(e),n=e instanceof HTMLImageElement?e.naturalWidth:e.width,i=e instanceof HTMLImageElement?e.naturalHeight:e.height;this.context.device.queue.copyExternalImageToTexture({source:t},{texture:this.context.texture("input",{format:"rgba8unorm"})},[n,i]),this.context.input=this.context.texture("input")}this.layers[0].inputs[0]=this.context.input,this.layers[1].inputs[0]=this.context.input,this.layers[this.layers.length-1].inputs[3]=this.context.input,this.layers.forEach((function(e){e.run()}))}))}}t.default=c},291:function(e,t,n){var i=this&&this.__awaiter||function(e,t,n,i){return new(n||(n=Promise))((function(r,u){function s(e){try{a(i.next(e))}catch(e){u(e)}}function o(e){try{a(i.throw(e))}catch(e){u(e)}}function a(e){var t;e.done?r(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(s,o)}a((i=i.apply(e,t||[])).next())}))};Object.defineProperty(t,"__esModule",{value:!0});const r=n(181),u=n(844),s=n(301),o=n(14),a=n(49);class f extends r.default{constructor(e){super(e)}model(){const e=[],t=this.weights.layers,n=this.context,i=new u.default([n.input],n.buffer("conv2d_tf"),t.conv2d_tf),r=new s.default([n.buffer("conv2d_tf")],n.buffer("conv2d_1_tf"),t.conv2d_1_tf),f=new s.default([n.buffer("conv2d_1_tf")],n.buffer("conv2d_2_tf"),t.conv2d_2_tf),c=new s.default([n.buffer("conv2d_2_tf")],n.buffer("conv2d_3_tf"),t.conv2d_3_tf),l=new s.default([n.buffer("conv2d_3_tf")],n.buffer("conv2d_4_tf"),t.conv2d_4_tf),d=new s.default([n.buffer("conv2d_4_tf")],n.buffer("conv2d_5_tf"),t.conv2d_5_tf),h=new s.default([n.buffer("conv2d_5_tf")],n.buffer("conv2d_6_tf"),t.conv2d_6_tf),p=new o.default([n.buffer("conv2d_tf"),n.buffer("conv2d_1_tf"),n.buffer("conv2d_2_tf"),n.buffer("conv2d_3_tf"),n.buffer("conv2d_4_tf"),n.buffer("conv2d_5_tf"),n.buffer("conv2d_6_tf")],n.buffer("conv2d_7_tf"),t.conv2d_7_tf),v=new o.default([n.buffer("conv2d_tf"),n.buffer("conv2d_1_tf"),n.buffer("conv2d_2_tf"),n.buffer("conv2d_3_tf"),n.buffer("conv2d_4_tf"),n.buffer("conv2d_5_tf"),n.buffer("conv2d_6_tf")],n.buffer("conv2d_7_tf1"),t.conv2d_7_tf1),_=new o.default([n.buffer("conv2d_tf"),n.buffer("conv2d_1_tf"),n.buffer("conv2d_2_tf"),n.buffer("conv2d_3_tf"),n.buffer("conv2d_4_tf"),n.buffer("conv2d_5_tf"),n.buffer("conv2d_6_tf")],n.buffer("conv2d_7_tf2"),t.conv2d_7_tf2),x=new a.default([n.buffer("conv2d_7_tf"),n.buffer("conv2d_7_tf1"),n.buffer("conv2d_7_tf2"),n.input],n.texture("output"));return e.push(i,r,f,c,l,d,h,p,v,_,x),e}feedForward(e){return i(this,void 0,void 0,(function*(){if(e instanceof HTMLVideoElement)this.context.input=this.context.device.importExternalTexture({source:e});else{const t=e instanceof ImageBitmap?e:yield createImageBitmap(e),n=e instanceof HTMLImageElement?e.naturalWidth:e.width,i=e instanceof HTMLImageElement?e.naturalHeight:e.height;this.context.device.queue.copyExternalImageToTexture({source:t},{texture:this.context.texture("input",{format:"rgba8unorm"})},[n,i]),this.context.input=this.context.texture("input")}this.layers[0].inputs[0]=this.context.input,this.layers[this.layers.length-1].inputs[3]=this.context.input,this.layers.forEach((function(e){e.run()}))}))}}t.default=f},505:function(e,t,n){var i=this&&this.__awaiter||function(e,t,n,i){return new(n||(n=Promise))((function(r,u){function s(e){try{a(i.next(e))}catch(e){u(e)}}function o(e){try{a(i.throw(e))}catch(e){u(e)}}function a(e){var t;e.done?r(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(s,o)}a((i=i.apply(e,t||[])).next())}))};Object.defineProperty(t,"__esModule",{value:!0});const r=n(181),u=n(844),s=n(301),o=n(24);class a extends r.default{constructor(e){super(e)}model(){const e=[],t=this.weights.layers,n=this.context,i=new u.default([n.input],n.buffer("conv2d_tf"),t.conv2d_tf),r=new s.default([n.buffer("conv2d_tf")],n.buffer("conv2d_1_tf"),t.conv2d_1_tf),a=new s.default([n.buffer("conv2d_1_tf")],n.buffer("conv2d_2_tf"),t.conv2d_2_tf),f=new s.default([n.buffer("conv2d_2_tf")],n.buffer("conv2d_last_tf"),t.conv2d_last_tf),c=new o.default([n.buffer("conv2d_last_tf"),n.input],n.texture("output"));return e.push(i,r,a,f,c),e}feedForward(e){return i(this,void 0,void 0,(function*(){if(e instanceof HTMLVideoElement)this.context.input=this.context.device.importExternalTexture({source:e});else{const t=e instanceof ImageBitmap?e:yield createImageBitmap(e),n=e instanceof HTMLImageElement?e.naturalWidth:e.width,i=e instanceof HTMLImageElement?e.naturalHeight:e.height;this.context.device.queue.copyExternalImageToTexture({source:t},{texture:this.context.texture("input",{format:"rgba8unorm"})},[n,i]),this.context.input=this.context.texture("input")}this.layers[0].inputs[0]=this.context.input,this.layers[this.layers.length-1].inputs[1]=this.context.input,this.layers.forEach((function(e){e.run()}))}))}}t.default=a},964:function(e,t,n){var i=this&&this.__awaiter||function(e,t,n,i){return new(n||(n=Promise))((function(r,u){function s(e){try{a(i.next(e))}catch(e){u(e)}}function o(e){try{a(i.throw(e))}catch(e){u(e)}}function a(e){var t;e.done?r(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(s,o)}a((i=i.apply(e,t||[])).next())}))};Object.defineProperty(t,"__esModule",{value:!0});const r=n(181),u=n(844),s=n(82),o=n(530);class a extends r.default{constructor(e){super(e)}model(){const e=[],t=this.weights.layers,n=this.context;e.push(new u.default([n.input],n.buffer("conv2d_tf"),t.conv2d_tf)),e.push(new u.default([n.input],n.buffer("conv2d_tf1"),t.conv2d_tf1));for(let i=1;i<4;i++){let r=1==i?"conv2d_tf":`conv2d_${i-1}_tf`;e.push(new s.default([n.buffer(r),n.buffer(r+"1")],n.buffer(`conv2d_${i}_tf`),t[`conv2d_${i}_tf`])),e.push(new s.default([n.buffer(r),n.buffer(r+"1")],n.buffer(`conv2d_${i}_tf1`),t[`conv2d_${i}_tf1`]))}e.push(new s.default([n.buffer("conv2d_3_tf"),n.buffer("conv2d_3_tf1")],n.buffer("conv2d_out_tf"),t.conv2d_out_tf));const i=new o.default([n.buffer("conv2d_out_tf"),n.input],n.texture("output"));return e.push(i),e}feedForward(e){return i(this,void 0,void 0,(function*(){if(e instanceof HTMLVideoElement)this.context.input=this.context.device.importExternalTexture({source:e});else{const t=e instanceof ImageBitmap?e:yield createImageBitmap(e),n=e instanceof HTMLImageElement?e.naturalWidth:e.width,i=e instanceof HTMLImageElement?e.naturalHeight:e.height;this.context.device.queue.copyExternalImageToTexture({source:t},{texture:this.context.texture("input",{format:"rgba8unorm"})},[n,i]),this.context.input=this.context.texture("input")}this.layers[0].inputs[0]=this.context.input,this.layers[1].inputs[0]=this.context.input,this.layers[this.layers.length-1].inputs[1]=this.context.input,this.layers.forEach((function(e){e.run()}))}))}}t.default=a},35:function(e,t,n){var i=this&&this.__awaiter||function(e,t,n,i){return new(n||(n=Promise))((function(r,u){function s(e){try{a(i.next(e))}catch(e){u(e)}}function o(e){try{a(i.throw(e))}catch(e){u(e)}}function a(e){var t;e.done?r(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(s,o)}a((i=i.apply(e,t||[])).next())}))};Object.defineProperty(t,"__esModule",{value:!0});const r=n(181),u=n(844),s=n(301),o=n(14),a=n(530);class f extends r.default{constructor(e){super(e)}model(){const e=[],t=this.weights.layers,n=this.context,i=new u.default([n.input],n.buffer("conv2d_tf"),t.conv2d_tf),r=new s.default([n.buffer("conv2d_tf")],n.buffer("conv2d_1_tf"),t.conv2d_1_tf),f=new s.default([n.buffer("conv2d_1_tf")],n.buffer("conv2d_2_tf"),t.conv2d_2_tf),c=new s.default([n.buffer("conv2d_2_tf")],n.buffer("conv2d_3_tf"),t.conv2d_3_tf),l=new s.default([n.buffer("conv2d_3_tf")],n.buffer("conv2d_4_tf"),t.conv2d_4_tf),d=new s.default([n.buffer("conv2d_4_tf")],n.buffer("conv2d_5_tf"),t.conv2d_5_tf),h=new s.default([n.buffer("conv2d_5_tf")],n.buffer("conv2d_6_tf"),t.conv2d_6_tf),p=new o.default([n.buffer("conv2d_tf"),n.buffer("conv2d_1_tf"),n.buffer("conv2d_2_tf"),n.buffer("conv2d_3_tf"),n.buffer("conv2d_4_tf"),n.buffer("conv2d_5_tf"),n.buffer("conv2d_6_tf")],n.buffer("conv2d_out_tf"),t.conv2d_out_tf),v=new a.default([n.buffer("conv2d_out_tf"),n.input],n.texture("output"));return e.push(i,r,f,c,l,d,h,p,v),e}feedForward(e){return i(this,void 0,void 0,(function*(){if(e instanceof HTMLVideoElement)this.context.input=this.context.device.importExternalTexture({source:e});else{const t=e instanceof ImageBitmap?e:yield createImageBitmap(e),n=e instanceof HTMLImageElement?e.naturalWidth:e.width,i=e instanceof HTMLImageElement?e.naturalHeight:e.height;this.context.device.queue.copyExternalImageToTexture({source:t},{texture:this.context.texture("input",{format:"rgba8unorm"})},[n,i]),this.context.input=this.context.texture("input")}this.layers[0].inputs[0]=this.context.input,this.layers[1].inputs[0]=this.context.input,this.layers[this.layers.length-1].inputs[1]=this.context.input,this.layers.forEach((function(e){e.run()}))}))}}t.default=f},673:function(e,t,n){var i=this&&this.__awaiter||function(e,t,n,i){return new(n||(n=Promise))((function(r,u){function s(e){try{a(i.next(e))}catch(e){u(e)}}function o(e){try{a(i.throw(e))}catch(e){u(e)}}function a(e){var t;e.done?r(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(s,o)}a((i=i.apply(e,t||[])).next())}))};Object.defineProperty(t,"__esModule",{value:!0});const r=n(181),u=n(844),s=n(301),o=n(530);class a extends r.default{constructor(e){super(e)}model(){const e=[],t=this.weights.layers,n=this.context,i=new u.default([n.input],n.buffer("conv2d_tf"),t.conv2d_tf),r=new s.default([n.buffer("conv2d_tf")],n.buffer("conv2d_1_tf"),t.conv2d_1_tf),a=new s.default([n.buffer("conv2d_1_tf")],n.buffer("conv2d_2_tf"),t.conv2d_2_tf),f=new s.default([n.buffer("conv2d_2_tf")],n.buffer("conv2d_out_tf"),t.conv2d_out_tf),c=new o.default([n.buffer("conv2d_out_tf"),n.input],n.texture("output"));return e.push(i,r,a,f,c),e}feedForward(e){return i(this,void 0,void 0,(function*(){if(e instanceof HTMLVideoElement)this.context.input=this.context.device.importExternalTexture({source:e});else{const t=e instanceof ImageBitmap?e:yield createImageBitmap(e),n=e instanceof HTMLImageElement?e.naturalWidth:e.width,i=e instanceof HTMLImageElement?e.naturalHeight:e.height;this.context.device.queue.copyExternalImageToTexture({source:t},{texture:this.context.texture("input",{format:"rgba8unorm"})},[n,i]),this.context.input=this.context.texture("input")}this.layers[0].inputs[0]=this.context.input,this.layers[this.layers.length-1].inputs[1]=this.context.input,this.layers.forEach((function(e){e.run()}))}))}}t.default=a},181:function(e,t){var n=this&&this.__awaiter||function(e,t,n,i){return new(n||(n=Promise))((function(r,u){function s(e){try{a(i.next(e))}catch(e){u(e)}}function o(e){try{a(i.throw(e))}catch(e){u(e)}}function a(e){var t;e.done?r(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(s,o)}a((i=i.apply(e,t||[])).next())}))};Object.defineProperty(t,"__esModule",{value:!0}),t.default=class{constructor(e){this.weights=e,this.context=globalThis.context,this.layers=this.model()}model(){return[]}lastLayer(){return this.layers[this.layers.length-1]}feedForward(e){return n(this,void 0,void 0,(function*(){this.layers.forEach((e=>{e.run()}))}))}}},386:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.NetworkScales=t.NetworkList=void 0;const i=n(505),r=n(291),u=n(892),s=n(964),o=n(35),a=n(673),f=n(126);t.NetworkList={"anime4k/cnn-2x-s":i.default,"anime4k/cnn-2x-m":r.default,"anime4k/cnn-2x-l":u.default,"anime4k/cnn-restore-s":a.default,"anime4k/cnn-restore-m":o.default,"anime4k/cnn-restore-l":s.default,"sb2702/blur-poc":f.default},t.NetworkScales={"anime4k/cnn-2x-s":2,"anime4k/cnn-2x-m":2,"anime4k/cnn-2x-l":2,"anime4k/cnn-restore-s":1,"anime4k/cnn-restore-m":1,"anime4k/cnn-restore-l":1,"sb2702/blur-poc":1}},126:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0});const i=n(181),r=n(831),u=n(863);class s extends i.default{constructor(){super()}model(){const e=[],t=this.context;return e.push(new r.default([t.texture("input")],t.texture("yuv"))),e.push(new u.default([t.texture("yuv")],t.texture("output"))),e}}t.default=s},518:function(e,t,n){var i=this&&this.__awaiter||function(e,t,n,i){return new(n||(n=Promise))((function(r,u){function s(e){try{a(i.next(e))}catch(e){u(e)}}function o(e){try{a(i.throw(e))}catch(e){u(e)}}function a(e){var t;e.done?r(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(s,o)}a((i=i.apply(e,t||[])).next())}))};Object.defineProperty(t,"__esModule",{value:!0});const r=n(24),u=n(200);t.default=class{constructor(e,t){this.context=globalThis.context,this.network=e,this.source=t,this.active=!1}switchNetwork(e){this.network=e}start(){return i(this,void 0,void 0,(function*(){if(this.context.destroyed)throw new Error("WebSR instance was destroyed");this.active=!0,yield this.renderStep()}))}stop(){return i(this,void 0,void 0,(function*(){this.active=!1,this.vfc&&this.source&&this.source instanceof HTMLVideoElement&&this.source.cancelVideoFrameCallback(this.vfc)}))}renderStep(){return i(this,void 0,void 0,(function*(){const e=this.network.lastLayer();e instanceof r.default&&e.setOutput(this.context.context.getCurrentTexture()),yield this.render(),this.active&&this.source&&this.source instanceof HTMLVideoElement&&(this.vfc=this.source.requestVideoFrameCallback(this.renderStep.bind(this)))}))}render(e){return i(this,void 0,void 0,(function*(){const t=this.network.lastLayer();t instanceof u.default&&t.setOutput(this.context.context.getCurrentTexture()),yield this.network.feedForward(e||this.source),yield this.context.device.queue.onSubmittedWorkDone()}))}}}},t={},n=function n(i){var r=t[i];if(void 0!==r)return r.exports;var u=t[i]={exports:{}};return e[i].call(u.exports,u,u.exports,n),u.exports}(540);return n.default})()));